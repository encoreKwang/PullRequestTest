# NtoT

Status: 시작 전

[https://minimin2.tistory.com/176](https://minimin2.tistory.com/176)

1. Tistory Config 설정 : Tistory API 등록 후 Authorization Code 방식으로 Access Token 발급받기
2. Notion Config 설정 : Notion 로그인 후 notion token 값인 쿠키의 token_v2의 값 가져오기→ Notion 로그인
3. Notion Export 객체 생성 및 설정파일 적용
4. 발행(POST)하거나 수정(MODIFY)할 Notion 페이지를 가져오고, 없으면 프로그램 종료
5. Config 파일에 적은 Kakao ID 및 PW를 이용하여, Selenium으로 로그인 수행
6. 로그인에 성공했다면, 해당 계정의 액세스 토큰을 발급받는다.
※ 해당 기능을 SNS로그인으로 수행한뒤 토큰만 가져오는 것으로 대체
7. Tistory에 발행하거나 수정할 Notion 페이지 링크(TABLE_PAGE_URL)를 입력받고 임시 경로(DOWNLOAD_DIR)에 해당 Notion 페이지를 .html로 다운로드 받는다.
8. download한 html파일을 parsing해서 업로드(포스팅)
9. os모듈에서 업로드한 페이지의 파일 path 삭제

'os' 모듈은 운영 체제와 상호 작용할 수 있는 방법을 제공하며, Python 코드가 플랫폼에 독립적으로 실행될 수 있도록 합니다. 'os' 모듈을 사용하여 Windows, Linux 및 Mac과 같은 다른 플랫폼에서도 수정 없이 코드를 작성할 수 있습니다.

그러나 코드가 다른 플랫폼 간에 이식 가능하도록 하려면 모든 플랫폼에서 정의된 함수 만 사용해야합니다. 예를 들어, unlink 및 opendir와 같은 함수는 모든 플랫폼에서 정의되어 있으므로 수정 없이 사용할 수 있습니다. 반면에 mkfifo 및 mknod와 같은 함수는 모든 플랫폼에서 정의되지 않으며, 사용하면 코드가 이식 불가능해질 수 있습니다.

마찬가지로 파일 경로를 직접 조작하는 대신 os.path 모듈을 사용해야합니다. os.path 모듈은 파일 경로를 플랫폼에 독립적으로 조작하는 데 사용할 수있는 split 및 join과 같은 함수를 제공합니다.

일관된 방식으로 'os' 모듈과 os.path 모듈을 사용하여 코드가 수정 없이 다른 플랫폼에서 실행되도록하면됩니다.

- 0417
    - 깃 허브 로그인 요청 api + 토큰 받기
    
    [https://park-algorithm.tistory.com/entry/Github-OAuth-로그인-구현하기?category=1241947?category=1241947](https://park-algorithm.tistory.com/entry/Github-OAuth-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0?category=1241947?category=1241947)
    
    [https://devkkiri.com/post/542d8419-6fb1-4e28-bbbe-d68f832fd78a](https://devkkiri.com/post/542d8419-6fb1-4e28-bbbe-d68f832fd78a)
    
- 0420
    - 깃 허브 토큰 받기 성공
    - [https://uknowblog.tistory.com/37#2.2. 포스트맨에 토큰 저장하기](https://uknowblog.tistory.com/37#2.2.%20%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%A7%A8%EC%97%90%20%ED%86%A0%ED%81%B0%20%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0)
    - [https://developers.notion.com/docs/authorization#public-integration-auth-flow-set-up](https://developers.notion.com/docs/authorization#public-integration-auth-flow-set-up)
    - 
    - [https://blog.naver.com/PostView.naver?blogId=jogilsang&logNo=222194830631&categoryNo=35&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=postView](https://blog.naver.com/PostView.naver?blogId=jogilsang&logNo=222194830631&categoryNo=35&parentCategoryNo=0&viewDate=&currentPage=1&postListTopCurrentPage=1&from=postView)
    - [https://www.google.com/search?q=포스트맨+base64&oq=포스트맨+base64&aqs=chrome..69i57.4858j0j7&sourceid=chrome&ie=UTF-8](https://www.google.com/search?q=%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%A7%A8+base64&oq=%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%A7%A8+base64&aqs=chrome..69i57.4858j0j7&sourceid=chrome&ie=UTF-8)
    - [https://testmanager.tistory.com/343](https://testmanager.tistory.com/343)
- 0421
    - NOTION 토큰 받기 성공
        
        ![Untitled](NtoT%2002ac86c456e4497f8e1f6b3d8a018dbe/Untitled.png)
        
        ![Untitled](NtoT%2002ac86c456e4497f8e1f6b3d8a018dbe/Untitled%201.png)
        
    - [https://math-coding.tistory.com/159](https://math-coding.tistory.com/159)
    - notion to markdown
        - [https://github.com/souvikinator/notion-to-md](https://github.com/souvikinator/notion-to-md)
    - github token
        - [https://withhamit.tistory.com/493](https://withhamit.tistory.com/493)
        - [https://ar-tec.tistory.com/83](https://ar-tec.tistory.com/83)
    - 
    
    GitHub OAuth App에서 발급되는 Access Token과 GitHub Developer의 Personal Access Token은 비슷한 역할을 수행하지만 몇 가지 중요한 차이점이 있습니다.
    
    GitHub OAuth App에서 발급되는 Access Token은 OAuth 인증 프로세스를 통해 사용자 또는 조직 계정의 권한으로 발급됩니다. 이 Access Token을 사용하면 해당 사용자 또는 조직 계정이 승인한 범위 내에서 API 작업을 수행할 수 있습니다. OAuth App에서 발급된 Access Token은 일반적으로 애플리케이션에서 사용자 또는 조직 계정의 데이터에 접근하는 데 사용됩니다.
    
    반면에, GitHub Developer의 Personal Access Token은 GitHub 계정의 개발자 설정에서 생성됩니다. 이 Token은 특정 사용자 또는 조직의 모든 데이터에 액세스할 수 있습니다. 개발자는 이 Token을 사용하여 일관된 권한으로 GitHub API 작업을 수행할 수 있습니다. 개발자가 생성한 Personal Access Token은 개발자의 GitHub 계정과 연결되어 있으며, 계정이 삭제되면 해당 Token도 삭제됩니다.
    
    따라서, OAuth App에서 발급된 Access Token은 API 작업 범위를 제한하여 애플리케이션 사용자가 액세스할 수 있는 GitHub 데이터에 대한 보안을 강화합니다. 반면에, GitHub Developer의 Personal Access Token은 개발자의 GitHub 계정과 연결되어 있으므로 보안 위험을 최소화하기 위해 GitHub 계정 소유자만 생성하고 사용해야합니다.
    
- 0424
    
    [https://ar-tec.tistory.com/83](https://ar-tec.tistory.com/83)
    
    - [https://groups.google.com/g/github-api/c/sEzMKaDNiu4](https://groups.google.com/g/github-api/c/sEzMKaDNiu4)
    - [https://www.programcreek.com/java-api-examples/?api=org.kohsuke.github.GHCommit](https://www.programcreek.com/java-api-examples/?api=org.kohsuke.github.GHCommit)
    - [https://www.programcreek.com/java-api-examples/?api=org.kohsuke.github.GHCommit](https://www.programcreek.com/java-api-examples/?api=org.kohsuke.github.GHCommit)
    - [https://velog.io/@ddclub12/JGIT-Simple하게-사용하기](https://velog.io/@ddclub12/JGIT-Simple%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)
    - git clone 성공
    - [https://git-scm.com/book/ko/v2/부록-B%3A-애플리케이션에-Git-넣기-JGit](https://git-scm.com/book/ko/v2/%EB%B6%80%EB%A1%9D-B%3A-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%97%90-Git-%EB%84%A3%EA%B8%B0-JGit)
    - [https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/CommitFile.java](https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/CommitFile.java)
    - 
    
    org.eclipse.jgit.errors.TransportException: [https://github.com/encoreKwang/PullRequestTest:](https://github.com/encoreKwang/PullRequestTest:) git-receive-pack not permitted on '[https://github.com/encoreKwang/PullRequestTest/](https://github.com/encoreKwang/PullRequestTest/)'
    at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:692) ~[org.eclipse.jgit-6.5.0.202303070854-r.jar:6.5.0.202303070854-r]
    at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:627) ~[org.eclipse.jgit-6.5.0.202303070854-r.jar:6.5.0.202303070854-r]
    
    ![Untitled](NtoT%2002ac86c456e4497f8e1f6b3d8a018dbe/Untitled%202.png)
    
- 0425
    - [https://blog.aaronroh.org/107](https://blog.aaronroh.org/107)
    - OAuth App : 사용자가 접근 가능한 것에 요청 가능
    - Github App : 필요한 것만 엑세스 요청 가능, 코드에 대한 읽기/쓰기 권한이 없음, issue, labels, milestones 관리 가능
    - 웹 어플리케이션 플로우
        1. 사용자가 깃헙 정보를 입력하도록 리다이렉트됨
        2. 깃헙에서 로그인을 거쳐 Authorize 후 서버(서비스되는 서버의 callback url)로 돌아옴
        3. 유저의 Access token을 통해 API에 접근 가능
    - [`https://github.com/login/oauth/authorize?scope=repo,user&client_id=9c456c2ea6b092fcfd0f`](https://github.com/login/oauth/authorize?scope=repo,user&client_id=9c456c2ea6b092fcfd0f) 
    REPO에 접근 가능하기 위해 `SCOPE` 설정한 해당 url로 ATK 받아오기
    - [https://velog.io/@shyuuuuni/OAuth-알아보기-with-github-로그인#1-자원-소유자-resource-owner](https://velog.io/@shyuuuuni/OAuth-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-with-github-%EB%A1%9C%EA%B7%B8%EC%9D%B8#1-%EC%9E%90%EC%9B%90-%EC%86%8C%EC%9C%A0%EC%9E%90-resource-owner)
    - 
- 0426
    
    github OAuth App
    ID: [nogari206@gmail.com](mailto:nogari206@gmail.com)
    비밀번호: Tkvlshrkfl206!
    client-id : 7e06fc5ef20cdc465a15
    code 요청 url : [`https://github.com/login/oauth/authorize?scope=repo,user&client_id](https://github.com/login/oauth/authorize?scope=repo,user&client_id=9c456c2ea6b092fcfd0f)=`7e06fc5ef20cdc465a15
    ATK : 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
    
    Notion API
    인증URL : 
    
    [https://api.notion.com/v1/oauth/authorize?client_id=09796e64-c53d-4b97-8973-5bf3e30001ab&response_type=code&owner=user&redirect_uri=https%3A%2F%2Fk8c206.p.ssafy.io%2Foauth%2Fnotion](https://api.notion.com/v1/oauth/authorize?client_id=09796e64-c53d-4b97-8973-5bf3e30001ab&response_type=code&owner=user&redirect_uri=https%3A%2F%2Fk8c206.p.ssafy.io%2Foauth%2Fnotion)
    
    카카오 OAuth
    [kauth.kakao.com/oauth/authorize?client_id=bf3e099e7c5935f31e4a35649dbfadc9&redirect_uri=http://localhost:8080/api/v1/oauth/kakao&response_type=code](https://meeting.ssafy.com/s08p30c2/channels/kauth.kakao.com/oauth/authorize?client_id=bf3e099e7c5935f31e4a35649dbfadc9&redirect_uri=http://localhost:8080/api/v1/oauth/kakao&response_type=code)
    
- 0501
    
    [https://www.reddit.com/r/docker/comments/ivx1u3/how_to_access_an_external_server_folder_from_a/](https://www.reddit.com/r/docker/comments/ivx1u3/how_to_access_an_external_server_folder_from_a/)
    
    [https://stackoverflow.com/questions/63971636/how-to-access-an-external-server-folder-from-a-spring-boot-docker-container](https://stackoverflow.com/questions/63971636/how-to-access-an-external-server-folder-from-a-spring-boot-docker-container)
    
    [https://www.google.com/search?q=spring+boot+in+docker+external+folder&newwindow=1&ei=835PZMzsKPKl2roP5qaE0A4&ved=0ahUKEwiMsoaX4NP-AhXyklYBHWYTAeoQ4dUDCA8&uact=5&oq=spring+boot+in+docker+external+folder&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6DQgAEOQCENYEELADGAE6BAghEBU6BwghEKABEApKBAhBGABQ4wVYxhRg8xVoA3ABeACAAaYBiAG7CJIBAzAuOJgBAKABAcgBDcABAdoBBggBEAEYCQ&sclient=gws-wiz-serp](https://www.google.com/search?q=spring+boot+in+docker+external+folder&newwindow=1&ei=835PZMzsKPKl2roP5qaE0A4&ved=0ahUKEwiMsoaX4NP-AhXyklYBHWYTAeoQ4dUDCA8&uact=5&oq=spring+boot+in+docker+external+folder&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIFCCEQoAE6CggAEEcQ1gQQsAM6DQgAEOQCENYEELADGAE6BAghEBU6BwghEKABEApKBAhBGABQ4wVYxhRg8xVoA3ABeACAAaYBiAG7CJIBAzAuOJgBAKABAcgBDcABAdoBBggBEAEYCQ&sclient=gws-wiz-serp)
    
- 0502
    
    [http://k8c206.p.ssafy.io:9090/](http://k8c206.p.ssafy.io:9090/)
    [https://k8c206.p.ssafy.io/](https://k8c206.p.ssafy.io/)
    
    - [qkrtlgud3286@naver.com](mailto:qkrtlgud3286@naver.com)
    - 1234
    
    ec2 backimg 컨테이너 안에 폴더 만들고 git clone 성공
    
    docker exec -it backimg /bin/bash
    
    ec2안에 컨테이너(작은 컴퓨터)안에 경로(/app) 가 기본 경로임.
    따라서 docker exec으로 컨테이너 안에서 설정한 경로로 폴더가 생성됨.
    
    root@ip-172-26-0-98:/home/ubuntu# docker ps
    
    root@ip-172-26-0-98:/home/ubuntu# docker exec -it backimg /bin/bash
    
    root@b43f855abd49:/app# pwd
    /app
    
    root@b43f855abd49:/app# cd /home/ubuntu
    root@b43f855abd49:/home/ubuntu# ls
    dir1
    root@b43f855abd49:/home/ubuntu# cd dir1
    root@b43f855abd49:/home/ubuntu/dir1# ls
    NewTest.txt  fc273439-eb84-47d3-936e-8ebe89d32950.txt  prTest.txt
    root@b43f855abd49:/home/ubuntu/dir1# exit
    

- 0503
    
    중첩된 JSON 형태는 MultiValueMap<String, String> 객체로 직접 추가할 수 없습니다. 대신, MultiValueMap<String, Object>를 사용하여 복합 데이터를 전송할 수 있습니다.
    
    예를 들어, 다음과 같은 중첩된 JSON 데이터가 있다고 가정해 봅시다.
    
    ```
    {
        "name": "John Doe",
        "address": {
            "street": "123 Main St",
            "city": "Anytown",
            "state": "CA",
            "zip": "12345"
        }
    }
    
    ```
    
    이 데이터를 RestTemplate으로 전송하려면 MultiValueMap<String, Object> 객체를 만들고, 내부의 Map<String, Object>를 사용하여 데이터를 추가해야 합니다.
    
    ```
    MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
    body.add("name", "John Doe");
    
    Map<String, Object> address = new LinkedHashMap<>();
    address.put("street", "123 Main St");
    address.put("city", "Anytown");
    address.put("state", "CA");
    address.put("zip", "12345");
    
    body.add("address", address);
    
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    
    HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);
    
    ResponseEntity<String> response = restTemplate.exchange(
        url,
        HttpMethod.POST,
        requestEntity,
        String.class
    );
    
    ```
    
    이 예제에서는 MultiValueMap<String, Object> 객체를 만들고, "name"과 "address"라는 키를 사용하여 데이터를 추가했습니다. "address"의 값은 Map<String, Object> 객체로 만들어 내부 데이터를 추가했습니다.
    
    그런 다음, HttpHeaders를 설정하고 HttpEntity<MultiValueMap<String, Object>> 객체를 만듭니다. 이 HttpEntity 객체를 사용하여 RestTemplate의 exchange() 메서드를 호출하면 HTTP 요청이 실행됩니다.
    
    GitHub API를 사용하여 파일을 업로드할 때, `path`는 업로드하려는 파일의 경로를 나타냅니다.
    
    GitHub API에서는 `path`를 통해 업로드하려는 파일의 저장 위치를 지정합니다. `path`는 파일이 저장될 디렉토리와 파일 이름으로 이루어져 있습니다. 예를 들어, `/path/to/file.txt`와 같은 형식으로 지정할 수 있습니다.
    
    GitHub API에서 파일을 업로드하려면, 업로드하려는 파일의 내용을 Base64 인코딩하여 JSON 요청 본문에 포함해야 합니다. 아래는 Spring에서 `RestTemplate`을 사용하여 GitHub API를 호출하여 파일을 업로드하는 예제 코드입니다.
    
    ```java
    RestTemplate restTemplate = new RestTemplate();
    
    // 업로드할 파일의 내용을 읽어옵니다.
    byte[] fileBytes = Files.readAllBytes(new File("file.txt").toPath());
    String fileContent = Base64.getEncoder().encodeToString(fileBytes);
    
    // 업로드할 파일의 경로를 지정합니다.
    String filePath = "/path/to/file.txt";
    
    // GitHub API 요청 URL을 생성합니다.
    URI url = URI.create("<https://api.github.com/repos/{owner}/{repo}/contents/{path}>");
    url = UriComponentsBuilder.fromUri(url)
            .buildAndExpand("owner", "repo", filePath)
            .toUri();
    
    // GitHub API 요청 본문을 생성합니다.
    Map<String, String> request = new HashMap<>();
    request.put("message", "Add file");
    request.put("content", fileContent);
    
    // GitHub API를 호출하여 파일을 업로드합니다.
    HttpHeaders headers = new HttpHeaders();
    headers.setBearerAuth("YOUR_GITHUB_ACCESS_TOKEN");
    headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
    headers.setContentType(MediaType.APPLICATION_JSON);
    HttpEntity<Map<String, String>> entity = new HttpEntity<>(request, headers);
    ResponseEntity<JsonNode> response = restTemplate.exchange(url, HttpMethod.PUT, entity, JsonNode.class);
    
    // GitHub API 응답 결과를 확인합니다.
    if (response.getStatusCode().is2xxSuccessful()) {
        System.out.println("File uploaded successfully.");
    } else {
        System.out.println("Failed to upload file: " + response.getBody().get("message").asText());
    }
    
    ```
    
    이 코드에서는 업로드할 파일을 읽어온 후, `Base64.getEncoder()`를 사용하여 파일 내용을 Base64 인코딩합니다. 그리고 `RestTemplate`을 사용하여 GitHub API를 호출하여 파일을 업로드합니다. 요청 본문에는 업로드할 파일의 내용과 경로를 JSON 형식으로 포함하며, `HttpHeaders`를 사용하여 `Authorization` 헤더에 GitHub 액세스 토큰을 설정합니다.
    
    ---
    
    `JsonNode` 클래스는 Jackson JSON 라이브러리에서 제공하는 클래스로, JSON 데이터를 트리 구조로 표현합니다. Spring에서는 Jackson 라이브러리를 기본적으로 사용하므로, `JsonNode` 클래스를 사용하여 JSON 데이터를 다루는 것이 편리합니다.
    
    아래는 `JsonNode` 클래스를 구현한 예제 코드입니다.
    
    ```
    import com.fasterxml.jackson.databind.JsonNode;
    import com.fasterxml.jackson.databind.ObjectMapper;
    
    // JSON 데이터를 파싱하기 위한 ObjectMapper 인스턴스를 생성합니다.
    ObjectMapper objectMapper = new ObjectMapper();
    
    // GitHub API 응답 본문을 JSON으로 파싱합니다.
    JsonNode responseBody = objectMapper.readTree(response.getBody().toString());
    
    // JSON 데이터에서 필요한 정보를 추출합니다.
    String sha = responseBody.get("content").get("sha").asText();
    
    ```
    
    위의 코드에서는 `ObjectMapper` 클래스를 사용하여 JSON 데이터를 파싱합니다. `ObjectMapper` 인스턴스를 생성한 후, `readTree()` 메서드를 사용하여 GitHub API 응답 본문을 JSON 형태로 파싱합니다. 그리고 `JsonNode` 클래스에서 제공하는 메서드를 사용하여 JSON 데이터에서 필요한 정보를 추출할 수 있습니다.
    
    예를 들어, 위의 코드에서는 GitHub API에서 업로드한 파일의 SHA 값을 추출하기 위해, JSON 데이터에서 `content` 필드의 `sha` 값을 추출하였습니다.
    

- 0504
    - SCHEMA 추가
        - response에서 저장할 데이터
            - name: titletmp2.txt → 파일 이름
            - path : nogari/titletmp2.txt
            - html_url : [https://github.com/encoreKwang/PullRequestTest/blob/master/nogari/titletmp2.txt](https://github.com/encoreKwang/PullRequestTest/blob/master/nogari/titletmp2.txt) → 발행링크
            - sha →
        - sha 없이 동일한 파일명으로 업로드 test -> 실패
        - sha는 동일한데 파일명과 filePath가 다른 경우 test -> 기존은 파일은 그대로 유지고 새로운 filepath 위치에 새로운 파일명의 파일이 생김
        - sha는 동일한데 파일명은 같고 filePath는 다른 경우 test -> 기존의 파일은 그대로 유지고 새로운 filePath
        - ATK 이용해서 USER 정보 얻기 : id (회원 테이블)
            - id → login
        
    - upload에서 필요한 parameter
        - encoreKwang은 db에서 가져오고
        - repo 필요
        - 카테고리( 1 depth 폴더, 디폴트는 nogari) 필요
        - 파일 이름은 타이틀로 하고

- 0508
    
    [https://recordsoflife.tistory.com/331](https://recordsoflife.tistory.com/331)
    
    TODO LIST
    
    - 리포지토리 리스트 반환 메소드 리팩토링
    - 포스팅시 DB 삽입 코드
    - 포스팅한 리스트 반환 기능
    
    ```java
    @Override
    	public Object postNotionToGithubMultiThread(List<PostNotionToGithubDto> postNotionToGithubDtoList, Member member) {
    		// 초기 스레드 수 : 0, 코어 스레드 수 : 0, 최대 스레드 수 : Integer.MAX_VALUE
    		// 추가된 스레드가 60초동안 아무 작업을 수행하지 않으면 ThreadPool에서 제거한다.
    		executorService = Executors.newCachedThreadPool();
    
    		// 각 Thread별 실행결과를 반환받는 Future 리스트
    		// Future 객체는 다른 스레드들의 연산 결과를 반환받기 위해 사용하는 지연 완료 객체 (Pending Completion Object)이다.
    		List<Future<?>> futureList = new ArrayList<>();
    		List<Github> githubList = new ArrayList<>();
    		List<String[]> responseLinkList = new ArrayList<>();
    
    		String notionToken = member.getNotionToken();
    
    		for(PostNotionToGithubDto githubPosting : postNotionToGithubDtoList){
    			if(githubPosting.getStatus().equals("발행요청")){
    				// STEP1. [발행요청] Tistory 객체 DB 저장
    				Github github = Github.builder()
    					.repository(githubPosting.getRepository())
    					.requestLink(githubPosting.getRequestLink())
    					.categoryName(githubPosting.getCategoryName())
    					.filename(githubPosting.getFilename())
    					.status("발행요청")
    					//					.title(githubPosting.getTitle())
    					.member(member)
    					.build();
    				githubRepository.save(github);
    				githubList.add(github);
    
    				// STEP2. [awsLambdaAndTistoryPost] AWS Lambda 호출 및 각 스레드별 FutureList 추가
    				Future<?> future = executorService.submit(() -> {
    					responseLinkList.add(awsLambdaAndGithubPost(notionToken, githubPosting, member));
    				});
    				futureList.add(future);
    			}
    			// else if(githubPosting.getStatus().equals("수정요청")){
    			// 	// Tistory DTO에 ResponseLink가 제공되는 경우만 수정을 진행한다.
    			// 	if(!githubPosting.getResponseLink().equals("")){
    			// 		// STEP1. [수정요청] Tistory 객체 조회
    			// 		Tistory tistory = tistoryRepository.findByResponseLink(githubPosting.getResponseLink());
    			// 		tistory.setRequestLink(tistoryPosting.getRequestLink());
    			// 		tistory.setStatus("수정요청");
    			// 		tistoryList.add(tistory);
    			//
    			// 		// STEP2. [awsLambdaAndTistoryModify] AWS Lambda 호출 및 각 스레드별 FutureList 추가
    			// 		Future<?> future = executorService.submit(() -> {
    			// 			try{
    			// 				responseLinkList.add(awsLambdaAndTistoryModify(tistory.getPostId(), notionToken, tistoryPosting, member));
    			// 			} catch(HttpClientErrorException e){
    			// 				// 티스토리에서 이미 삭제된 게시글에 대해 수정 요청을 하는 경우
    			// 				tistory.setStatus("수정실패");
    			// 			} catch(JsonParseException e){
    			// 				// 입력값이 정상적으로 입력되지 않은 경우
    			// 				tistory.setStatus("수정실패");
    			// 			} catch(Exception e){
    			// 				e.printStackTrace();
    			// 				tistory.setStatus("수정실패");
    			// 			}
    			// 		});
    			// 		futureList.add(future);
    			// 	}
    			// }
    		}
    		System.out.println(executorService);
    
    		// STEP3. ExecutorService 종료 및 모든 스레드의 실행이 종료될 때까지 대기
    		try {
    			// ThreadPool에 대한 추가적인 Task 제출을 막는다.
    			executorService.shutdown();
    
    			// Nano Second 단위로, 현재 실행중인 Task들의 결과가 모두 반환될때까지 대기한다.
    			executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    
    		// STEP4. [발행완료|발행실패] Tistory 발행 상태 DB 갱신
    		// 각 발행 요청 스레드별 연산 결과를 모두 반환 받을때까지 대기하기 위해, future.get()을 사용한다.
    		// 서브 스레드별 연산 결과를 모두 반환 받을때까지 메인 스레드의 실행 흐름을 잠시 Block한다.
    		// int index = 0;
    		// for (Future<?> f : futureList) {
    		// 	try {
    		// 		f.get();
    		// 		tistoryList.get(index).setResponseLink(responseLinkList.get(index)[0]);
    		// 		tistoryList.get(index).setPostId(Long.parseLong(responseLinkList.get(index)[1]));
    		// 		tistoryList.get(index).setTitle(responseLinkList.get(index)[2]);
    		// 		tistoryList.get(index++).setStatus("발행완료");
    		// 	} catch (InterruptedException e) {
    		// 		e.printStackTrace();
    		// 		tistoryList.get(index).setResponseLink(responseLinkList.get(index)[0]);
    		// 		tistoryList.get(index).setPostId(Long.parseLong(responseLinkList.get(index)[1]));
    		// 		tistoryList.get(index).setTitle(responseLinkList.get(index)[2]);
    		// 		tistoryList.get(index++).setStatus("발행실패");
    		// 	} catch (ExecutionException e){
    		// 		e.printStackTrace();
    		// 		tistoryList.get(index).setResponseLink(responseLinkList.get(index)[0]);
    		// 		tistoryList.get(index).setPostId(Long.parseLong(responseLinkList.get(index)[1]));
    		// 		tistoryList.get(index).setTitle(responseLinkList.get(index)[2]);
    		// 		tistoryList.get(index++).setStatus("발행실패");
    		// 	} catch (IndexOutOfBoundsException e){
    		// 		tistoryList.get(index++).setStatus("수정실패");
    		// 	}
    		// }
    		return null;
    	}
    ```
    
    ```java
    public void upload(PostNotionToGithubDto githubPosting, Member member, String title, String content) throws IOException {
    		System.out.println("upload 시작");
    		System.out.println("upload title : " + title);
    		RestTemplate rt = new RestTemplate();
    		rt.setRequestFactory(new HttpComponentsClientHttpRequestFactory());
    
    		//파일명 중복 방지를 위한 현재 날짜, 시간
    		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd HH:mm:ss");
    		Date nowDate = new Date();
    		String fileDate = simpleDateFormat.format(nowDate);
    		System.out.println("upload filedate : " + fileDate);
    
    		HttpHeaders headers = new HttpHeaders();
    		headers.add("Accept", "application/vnd.github+json");
    		headers.add("Authorization", "Bearer " + member.getToken().getGithubToken());
    		headers.add("X-GitHub-Api-Version", "2022-11-28");
    		headers.setContentType(MediaType.APPLICATION_JSON);
    
    		// String dirPath = "C:\\nogari-git-test\\git-clone-test\\upload.txt";
    		// 	File gitDir = new File(dirPath);
    		// 	// 업로드할 파일의 내용을 읽어옵니다.
    		// 	byte[] fileBytes = Files.readAllBytes(gitDir.toPath());
    		// 	String fileContent = Base64.getEncoder().encodeToString(fileBytes);
    
    		String fileContent = Base64.getEncoder().encodeToString(content.getBytes());
    
    		Map<String, String> body = new LinkedHashMap<>();
    		body.put("message", "[UPLOAD] " + title);
    		body.put("content", fileContent);
    
    		//수정요청
    		// if(githubPosting.getStatus().equals("수정요청")){
    		// 	body.put("sha", githubPosting.getn);
    		// }
    
    		//committer 주석 처리
    		// Map<String, String> address = new LinkedHashMap<>();
    		// address.put("name", "encoreKwang");
    		// address.put("email", "dnflrhkddyd@naver.com");
    		// body.add("committer", address);
    
    		HttpEntity<Map<String, String>> uploadRequest = new HttpEntity<>(body, headers);
    		// String filePath = "C:\\nogari-git-test\\git-clone-test\\upload.txt";
    		;
    		String filePath = member.getGithubId() + "/" + githubPosting.getRepository() + "/contents/" +githubPosting.getCategoryName() +"/"+ title + "_" + fileDate + "."+ githubPosting.getType();
    		System.out.println("filePath : " +  filePath );
    		// String filePath = "/nogari2/titletmp2.txt";
    
    		ResponseEntity<String> response = rt.exchange(
    			// "https://api.github.com/repos/encoreKwang/PullRequestTest/contents" + filePath,
    			"https://api.github.com/repos/" + filePath,
    			HttpMethod.PUT,
    			uploadRequest,
    			String.class
    		);
    
    		String body1 = response.getBody();
    		System.out.println(body1);
    	}
    ```
    
- 0511
    
    [https://docs.github.com/ko/rest/repos/contents?apiVersion=2022-11-28](https://docs.github.com/ko/rest/repos/contents?apiVersion=2022-11-28)
    
    RES.JSON
    
    ```json
    {
      "content": {
        "name": "titletmp2.txt",
        "path": "nogari/titletmp2.txt",
        "sha": "96c36401ae22840df366b6c428cde9c9a2dcb147",
        "size": 15,
        "url": "https://api.github.com/repos/encoreKwang/PullRequestTest/contents/nogari/titletmp2.txt?ref=master",
        "html_url": "https://github.com/encoreKwang/PullRequestTest/blob/master/nogari/titletmp2.txt",
        "git_url": "https://api.github.com/repos/encoreKwang/PullRequestTest/git/blobs/96c36401ae22840df366b6c428cde9c9a2dcb147",
        "download_url": "https://raw.githubusercontent.com/encoreKwang/PullRequestTest/master/nogari/titletmp2.txt",
        "type": "file",
        "_links": {
          "self": "https://api.github.com/repos/encoreKwang/PullRequestTest/contents/nogari/titletmp2.txt?ref=master",
          "git": "https://api.github.com/repos/encoreKwang/PullRequestTest/git/blobs/96c36401ae22840df366b6c428cde9c9a2dcb147",
          "html": "https://github.com/encoreKwang/PullRequestTest/blob/master/nogari/titletmp2.txt"
        }
      },
      "commit": {
        "sha": "2a63197269cb92e21f44f271d80c08dcbbabe828",
        "node_id": "C_kwDOIunBvdoAKDJhNjMxOTcyNjljYjkyZTIxZjQ0ZjI3MWQ4MGMwOGRjYmJhYmU4Mjg",
        "url": "https://api.github.com/repos/encoreKwang/PullRequestTest/git/commits/2a63197269cb92e21f44f271d80c08dcbbabe828",
        "html_url": "https://github.com/encoreKwang/PullRequestTest/commit/2a63197269cb92e21f44f271d80c08dcbbabe828",
        "author": {
          "name": "이광용",
          "email": "58154661+encoreKwang@users.noreply.github.com",
          "date": "2023-05-04T00:22:36Z"
        },
        "committer": {
          "name": "이광용",
          "email": "58154661+encoreKwang@users.noreply.github.com",
          "date": "2023-05-04T00:22:36Z"
        },
        "tree": {
          "sha": "b51b53ae3717f9ac5bba17109268a80e95ad54f6",
          "url": "https://api.github.com/repos/encoreKwang/PullRequestTest/git/trees/b51b53ae3717f9ac5bba17109268a80e95ad54f6"
        },
        "message": "my commit message test",
        "parents": [
          {
            "sha": "6bd382c5a7acff6ef136fac6d49276c88b04e953",
            "url": "https://api.github.com/repos/encoreKwang/PullRequestTest/git/commits/6bd382c5a7acff6ef136fac6d49276c88b04e953",
            "html_url": "https://github.com/encoreKwang/PullRequestTest/commit/6bd382c5a7acff6ef136fac6d49276c88b04e953"
          }
        ],
        "verification": {
          "verified": false,
          "reason": "unsigned",
          "signature": null,
          "payload": null
        }
      }
    }
    ```
    
    - lambda, thread 통해서 github 포스팅 완료하고 db 삽입 완료
    - 수정 기능 구현
    - 1. [발행요청]은 사용자가 신규로 생성한 튜플에 대해서만 가능하다. -> requestLink를 검사한다.
    - 2. [발행실패]는 [발행요청]에 실패한 튜플로, 다시 [발행요청]을 시도한다. -> requestLink를 검사한다.  ⇒ `발행 실패는 여전히 남아있고 새로운 발행 요청의 결과로 발행완료가 생성된다.`
    - 3. [발행완료]는 [발행요청] 및 [발행실패]에 대해 발행이 완료된 상태로, [수정요청]이 가능하다. -> 아무 작업도 수행하지 않는다.
    - 4. [수정요청]은 사용자가 이미 발행했던 [발행완료] 튜플에 대해서만 가능하다. -> requestLink, responseLink를 검사한다.
    - 5. [수정실패]는 [수정요청]에 실패한 튜플로, 다시 [수정요청]을 시도한다. -> requestLink, responseLink를 검사한다.
    - 수정시 SHA 필드의 DB UPDATE 코드 추가함 → [수정 요청] 반복적으로 발행 성공 가능, [수정 실패] 발행 성공 가능
    
    modified:   back/src/main/java/me/nogari/nogari/api/aws/awsLambdaCallableGithub.java
    modified:   back/src/main/java/me/nogari/nogari/api/request/PostNotionToGithubDto.java
    modified:   back/src/main/java/me/nogari/nogari/api/service/ContentServiceImpl.java
    
    - todo
        - 사진, 동영상 업로드
        - 레포지토리에 들어있는 카테고리 리스트 가져오기
    
    - 0512
        
        알겠습니다. 노션 게시글을 .md 파일로 변경하고, 그 안에 이미지 링크를 만료 시간 없는 주소로 변경한 뒤에, 이 .md 파일을 Github API를 통해 업로드하는 방법이 있습니다.
        
        1. 노션 게시글을 .md 파일로 변경하기
        
        노션 내에서 게시글을 열고, 상단 메뉴에서 `...` 버튼을 누릅니다. 그 다음, `Export`를 선택합니다. `Export as`에서 `Markdown`을 선택하고 `Export` 버튼을 누르면 .md 파일이 다운로드됩니다.
        
        1. 이미지 주소 변경하기
        
        다운로드 받은 .md 파일을 텍스트 편집기로 열고, 이미지 주소를 변경합니다. 예를 들어, 만료 시간이 있는 이미지 주소 `https://s3-us-west-2.amazonaws.com/secure.notion-static.com/xxx/yyy.png?expires=timestamp&signature=signature`를 만료 시간 없는 주소 `https://s3-us-west-2.amazonaws.com/secure.notion-static.com/xxx/yyy.png`로 변경합니다. 이 작업을 수동으로 하지 않고 자동으로 처리할 수 있는 라이브러리도 있습니다.
        
        1. Github API를 통해 업로드하기
        
        노션 게시글을 .md 파일로 변경하고 이미지 주소를 변경한 뒤에, Github API를 통해 해당 파일을 업로드할 수 있습니다. 예를 들어, 다음과 같은 코드로 업로드할 수 있습니다.
        
        ```
        RestTemplate restTemplate = new RestTemplate();
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("Authorization", "Bearer " + accessToken);
        
        String url = "<https://api.github.com/repos/{owner}/{repo}/contents/{path}>";
        Map<String, String> urlVariables = new HashMap<>();
        urlVariables.put("owner", owner);
        urlVariables.put("repo", repo);
        urlVariables.put("path", path);
        
        String content = Base64.getEncoder().encodeToString(markdown.getBytes());
        
        Map<String, Object> request = new HashMap<>();
        request.put("message", "Add new markdown file");
        request.put("content", content);
        
        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(request, headers);
        ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.PUT, entity, Map.class, urlVariables);
        
        ```
        
        여기서 `accessToken`은 Github API에 접근하기 위한 토큰입니다. `owner`, `repo`, `path`는 업로드할 파일의 소유자, 레포지토리 이름, 파일 경로를 각각 대체하면 됩니다. `markdown` 변수에는 이미지 주소가 변경된 .md 파일의 내용이 들어갑니다. 이 코드를 실행하면 Github API를 통해 해당 파일이 업로드됩니다.
        
        이미지 주소에서 만료 시간과 서명(signature)을 제거하는 작업은 정규 표현식(regular expression)을 사용하여 간단하게 처리할 수 있습니다. 이를 지원하는 라이브러리는 다양하지만, 예를 들어 Java에서는 `java.util.regex` 패키지를 사용할 수 있습니다.
        
        아래는 Java에서 정규 표현식을 사용하여 이미지 주소에서 만료 시간과 서명을 제거하는 예시입니다.
        
        ```
        String imageUrl = "<https://s3-us-west-2.amazonaws.com/secure.notion-static.com/xxx/yyy.png?expires=timestamp&signature=signature>";
        String regex = "\\\\?expires=[^&]*&signature=[^&]*";
        String imageUrlWithoutExpireTimeAndSignature = imageUrl.replaceAll(regex, "");
        
        ```
        
        위 코드에서 `regex` 변수는 정규 표현식으로, 이미지 주소에서 `?expires=`와 `&signature=` 사이에 있는 문자열을 제거합니다. `replaceAll` 메소드는 정규 표현식과 일치하는 문자열을 두 번째 인자로 주어진 문자열로 대체합니다. 이렇게 처리하면 이미지 주소에서 만료 시간과 서명이 제거된 새로운 이미지 주소가 반환됩니다.
        
        변경된 이미지 주소를 확인해 보니, 만료 시간과 시그니처 모두 제거된 것 같습니다. 하지만, GitHub은 이미지 파일의 저장을 지원하지 않으므로, 이미지 파일 자체를 저장할 수 없습니다.
        
        대신, 이미지 파일을 인터넷에 공개된 서비스에 업로드하고 해당 URL을 포스팅할 수 있습니다. GitHub에서는 이미지 파일을 업로드할 수 없지만, 이슈(issue)나 댓글(comment)에 이미지를 포함할 수 있습니다. 이 기능을 이용하여 이미지 파일을 업로드하고, 이를 포스팅 내용에 링크하는 것이 좋습니다.
        
        만약 이미지 파일을 업로드하고 링크하는 방법이 궁금하다면, 다음 링크에서 이에 대한 자세한 설명을 확인하실 수 있습니다: [GitHub에서 이미지 파일 업로드하기](https://docs.github.com/en/issues/tracking-your-work-with-issues/adding-images-and-files-to-issues-and-pull-requests).
        
    -